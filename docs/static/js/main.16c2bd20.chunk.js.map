{"version":3,"sources":["utils/hooks.ts","store/tree/constants.ts","store/tree/utils.ts","store/tree/treeSlice.ts","components/Tree/TreeDBContainer.tsx","utils/usePopupState.ts","components/Tree/ItemModal.tsx","components/Tree/TreesContainer.tsx","pages/TreePage.tsx","app/App.tsx","app/store.ts","index.tsx"],"names":["useAppDispatch","useDispatch","useAppSelector","useSelector","defaultDBFlatTree","title","parent","deleted","key","getItemByKey","items","length","result","i","children","moveToParentByStep","findIndex","item","find","splice","push","reorderTree","tree","getFlatTreeItemsArray","limiter","movedChild","markItemAsDeleted","itemToDelete","startItem","markFlatTreeItemAsDeleted","pos","childrens","filter","dbItem","resultFlatTree","childs","getTreeFromFlatDB","nodes","childrenItems","adoptDBItemsToTree","treeItems","rootItem","getKeysFromFlatTree","keys","flatTree","applyCache","sourceItems","cache","resultSourceItems","resultCache","currentItem","posItem","uniqueKey","dbItems","parentKey","maxCount","appendIndexCount","generateUniqueKey","updateChildrenKeys","orderedResultSourceItems","resultItems","getFlatTreeItemsByKeys","oldParentKey","newParentKey","initialState","cacheExpandedKeys","itemsExpandedKeys","treeSlice","createSlice","name","reducers","add","state","action","payload","remove","alter","apply","reset","actions","selectCache","addItemAction","newItem","dispatch","getState","addItemToTree","deleteItemAction","cacheTree","cloneDeep","deleteItem","alterItemAction","itemToAltered","alterItem","reducer","TreeDBContainer","useState","selectedItem","setSelectedItem","expanded","style","minWidth","gutter","wrap","align","onClick","defaultExpandAll","checkStrictly","showIcon","icon","props","data","DeleteFilled","color","expandedKeys","onSelect","selectedKeysValue","info","selectedNodes","selectedKeys","treeData","usePopupState","initialOpen","isOpen","setIsOpen","onOpen","onClose","onToggle","ItemModal","visible","onOk","onCancel","value","setValue","useEffect","destroyOnClose","maskClosable","onChange","e","target","TreesContainer","setNewItem","isOpenAddModal","onToggleAddModal","isOpenAlterModal","onToggleAlterModal","freshItem","minHeight","marginTop","disabled","span","resultDBItems","TreePage","App","Header","textAlign","Content","padding","Footer","position","bottom","store","configureStore","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.16c2bd20.chunk.js","sourcesContent":["import { TypedUseSelectorHook, useDispatch, useSelector } from 'react-redux'\nimport type { RootState, AppDispatch } from '../app/store'\n\n// Use throughout your app instead of plain `useDispatch` and `useSelector`\nexport const useAppDispatch = () => useDispatch<AppDispatch>()\nexport const useAppSelector: TypedUseSelectorHook<RootState> = useSelector\n","import { DBTreeItemList } from './types'\n\nexport const rootDBKey = '0'\n\nexport const maxIterationCount = 1000\n/**\n * Default DB. key of each element is unique value. It used as a\n * pointer to parent element.\n * Root element has parent === ''\n */\nexport const defaultDBFlatTree: DBTreeItemList = {\n  [rootDBKey]: {\n    title: 'root title',\n    parent: '',\n    deleted: false,\n    key: '0'\n  },\n  '0-0': {\n    title: 'child of root - 0',\n    parent: '0',\n    deleted: false,\n    key: '0-0'\n  },\n  '0-0-0': {\n    title: '0-0-0',\n    parent: '0-0',\n    deleted: false,\n    key: '0-0-0'\n  },\n  '0-0-1': {\n    title: '0-0-1',\n    parent: '0-0',\n    deleted: false,\n    key: '0-0-1'\n  },\n  '0-0-0-0': {\n    title: '0-0-0-0',\n    parent: '0-0-1',\n    deleted: false,\n    key: '0-0-0-0'\n  },\n  '0-0-0-1': {\n    title: '0-0-0-1',\n    parent: '0-0-1',\n    deleted: false,\n    key: '0-0-0-1'\n  },\n  '0-0-0-0-0': {\n    title: '0-0-0-0-0',\n    parent: '0-0-0-1',\n    deleted: false,\n    key: '0-0-0-0-0'\n  },\n  '0-0-0-2': {\n    title: '0-0-0-2',\n    parent: '0-0-1',\n    deleted: false,\n    key: '0-0-0-2'\n  },\n  '0-0-2': {\n    title: '0-0-2',\n    parent: '0-0',\n    deleted: false,\n    key: '0-0-2'\n  },\n  '0-1': {\n    title: 'child of root - 1',\n    parent: '0',\n    deleted: false,\n    key: '0-1'\n  },\n  '0-1-0': {\n    title: '0-1-0',\n    parent: '0-1',\n    deleted: false,\n    key: '0-1-0'\n  },\n  '0-1-1': {\n    title: '0-1-1',\n    parent: '0-1',\n    deleted: false,\n    key: '0-1-1'\n  },\n  '0-1-2': {\n    title: '0-1-2',\n    parent: '0-1',\n    deleted: false,\n    key: '0-1-2'\n  },\n  '0-2': {\n    title: 'child of root - 2',\n    parent: '0',\n    deleted: false,\n    key: '0-2'\n  }\n}\n","import { cloneDeep } from 'lodash'\nimport { TreeItem, DBTreeItemList } from './types'\nimport { rootDBKey, maxIterationCount } from './constants'\n\n/**\n * Find item in tree by key\n * @param {TreeItem[]} items - array of TreeItem to find with\n * @param {string} key - key of searched item\n * @returns {TreeItem | null} - link to item with received key\n */\nexport const getItemByKey = (\n  items: TreeItem[] = [],\n  key: string\n): TreeItem | null => {\n  if (items.length) {\n    let result = null\n    for (let i = 0; result == null && i < items.length; i++) {\n      if (items[i].key === key) {\n        return items[i]\n      }\n      result = getItemByKey(items[i].children, key)\n    }\n    return result\n  }\n  return null\n}\n\n/**\n * Check for each item for child existing. If child exists than go to next\n * loop. If there ar not child than finding parent. If parent found than we\n * extract current item from array and put to parent. If parent was not\n * finded too, than go to next loop.\n * If No child and no parent for each element mean that we have ordered tree\n * @param {TreeItem[]} items - array of TreeItem to move item to his parent\n * @returns {TreeItem | null} - item wich was moved to parent\n */\nexport const moveToParentByStep = (items: TreeItem[] = []): TreeItem | null => {\n  let result = null\n  if (items.length) {\n    for (let i = 0; result == null && i < items.length; i++) {\n      // check for existing children\n      if (items.findIndex(item => item.parent === items[i].key) === -1) {\n        // check for existing parent\n        const parent = items.find(item => item.key === items[i].parent)\n        if (parent) {\n          result = items[i]\n          items.splice(i, 1)\n          parent.children.push(result)\n          return result\n        }\n      }\n    }\n  }\n  return result\n}\n\n/**\n * Reorder tree. Takes tree and place childrens to its parents.\n * @param {TreeItem[]} tree - disordered or ordered tree. Tree will be\n * rebuild anyway\n * @returns {TreeItem[]} - ordered tree\n */\nexport const reorderTree = (tree: TreeItem[]): TreeItem[] => {\n  let result = getFlatTreeItemsArray(tree)\n  let limiter = 0\n  let movedChild = null\n  do {\n    movedChild = moveToParentByStep(result)\n    limiter++\n  } while (movedChild != null && limiter < maxIterationCount)\n  return result\n}\n\n/**\n * Mark item as \"deleted\". Preparing array for changing and call\n * recursive delete function on prepared array\n * @param {TreeItem[]} cache - current view tree\n * @param {TreeItem} item - item to be deleted\n *\n */\nexport const deleteItem = (\n  cache: TreeItem[] = [],\n  itemToDelete: TreeItem = {} as TreeItem\n) => {\n  const cacheTree = cloneDeep(cache)\n  itemToDelete.deleted = !itemToDelete.deleted\n  markItemAsDeleted(cacheTree, itemToDelete)\n  return cacheTree\n}\n\n/**\n * Mark item as \"deleted\" recursively from entire tree\n * @param {TreeItem[]} cache - current view tree\n * @param {TreeItem} item - item to be deleted\n *\n */\nexport const markItemAsDeleted = (\n  tree: TreeItem[],\n  itemToDelete: TreeItem = {} as TreeItem\n) => {\n  const startItem = getItemByKey(tree, itemToDelete.key)\n  if (startItem) {\n    // delete item and all his children\n    startItem.deleted = itemToDelete.deleted\n    for (let i = 0; i < startItem.children.length; i++) {\n      markItemAsDeleted(startItem.children, {\n        ...startItem.children[i],\n        deleted: itemToDelete.deleted\n      })\n    }\n  }\n}\n\n/**\n * mark item in flat array TreeItem[] as deleted\n * @param {TreeItem[]} items - items array where we should mark item deleted\n * @param {TreeItem} item - item to be deleted\n */\nexport const markFlatTreeItemAsDeleted = (\n  items: TreeItem[] = [],\n  itemToDelete: TreeItem = {} as TreeItem\n) => {\n  // first step delete item itself\n  const pos = items.findIndex(item => item.key === itemToDelete.key)\n  if (pos !== -1) {\n    items[pos].deleted = itemToDelete.deleted\n  }\n  // delete children\n  const childrens = items.filter(dbItem => dbItem.parent === itemToDelete.key)\n  for (let i = 0; i < childrens.length; i++) {\n    childrens[i].deleted = itemToDelete.deleted\n    markFlatTreeItemAsDeleted(items, childrens[i])\n  }\n}\n\n/**\n * Alter item's title.\n * @param {TreeItem[]} cache - current view tree\n * @param {TreeItem} item - item to be altered\n * @returns {TreeItem[]} - returns new cache with altered item title\n */\nexport const alterItem = (\n  cache: TreeItem[] = [],\n  itemToAltered: TreeItem = {} as TreeItem\n) => {\n  const resultCache = cloneDeep(cache)\n  const alterItem = getItemByKey(resultCache, itemToAltered.key)\n  if (alterItem) {\n    alterItem.title = itemToAltered.title\n  }\n  return resultCache\n}\n\n/**\n * Add item to tree\n * @param {TreeItem[]} cache - current view tree\n * @param {TreeItem} item - item to be added\n * @returns {TreeItem[]} - result tree with new item\n */\nexport const addItemToTree = (\n  tree: TreeItem[] = [] as TreeItem[],\n  newItem: TreeItem = {} as TreeItem\n): TreeItem[] => {\n  const flatTree = getFlatTreeItemsArray(tree)\n  if (flatTree.findIndex(item => item.key === newItem.key) === -1) {\n    flatTree.push(newItem)\n  }\n  for (let i = 0; i < flatTree.length; i++) {\n    if (flatTree[i].deleted) {\n      markFlatTreeItemAsDeleted(flatTree, flatTree[i])\n    }\n  }\n  const orderedTree = reorderTree(flatTree)\n\n  return orderedTree\n}\n\n/**\n * returns flatten tree from tree\n * @param {TreeItem[]} tree - tree for flatting\n * @returns {DBTreeItem[]} - flat tree\n */\nexport const getFlatTreeItemsArray = (tree: TreeItem[]): TreeItem[] => {\n  const resultFlatTree = [] as TreeItem[]\n  for (const i in tree) {\n    const childs = getFlatTreeItemsArray(tree[i]?.children)\n    resultFlatTree.push({ ...tree[i], children: [] }, ...childs)\n  }\n  return resultFlatTree\n}\n\n/**\n * Returns tree for given root node key from flat source DB\n * @param {DBTreeItemList} nodes - original DB with root\n * @param {string} parent - root node key. It can be any node element. Tree\n * will be created from received key\n * @returns {TreeItem[]}  - result tree\n */\nexport const getTreeFromFlatDB = (\n  nodes: DBTreeItemList,\n  parent: string\n): TreeItem[] => {\n  const childrenItems = [] as TreeItem[]\n  for (const key in nodes) {\n    if (nodes[key].parent === parent) {\n      const children = getTreeFromFlatDB(nodes, key)\n      childrenItems.push({ ...nodes[key], ...{ children } })\n    }\n  }\n  return childrenItems\n}\n\n/**\n * Returns tree for given flat tree. Root will be finded throughout received\n * array with empty parent\n * @param {DBTreeItemList} nodes - flat tree. Only root has no parent\n * @returns {TreeItem[]}  - result tree\n */\nexport const adoptDBItemsToTree = (\n  items: DBTreeItemList = {} as DBTreeItemList\n): TreeItem[] => {\n  const treeItems = [] as TreeItem[]\n  const rootItem = { ...items[rootDBKey] }\n  // check for existing root item. If we have no root, than return empty array\n  if (rootItem.key) {\n    const children = getTreeFromFlatDB(items, rootItem.key)\n    treeItems.push({ ...rootItem, children })\n  }\n\n  return treeItems\n}\n\n/**\n * get all keys array from tree. For fetch updated items from\n * original DB to cache. Because delete operation may take effect\n * on missed cache items\n * @param {TreeItem[]} tree - flat tree of cache\n * @returns {string[]} - keys array\n */\nexport const getKeysFromFlatTree = (tree: TreeItem[]): string[] => {\n  const keys = [] as string[]\n  const flatTree = getFlatTreeItemsArray(tree)\n  for (const i in flatTree) {\n    keys.push(flatTree[i].key)\n  }\n  return keys\n}\n\n/**\n * Generate unuque key for new item. It based on real DB items keys.\n * @param {TreeItem[]} dbItems - source flat DB tree with original keys\n * @param {string} parentKey - key of parent wich will be base for build\n * unique key\n * @returns {string} - unique key\n */\nexport const generateUniqueKey = (\n  dbItems: TreeItem[] = [],\n  parentKey: string\n): string => {\n  // maxCount for prevent infinity loop\n  const maxCount = 1000\n  let appendIndexCount = 0\n  while (appendIndexCount < maxCount) {\n    const key = `${parentKey}-${appendIndexCount}`\n    if (dbItems.findIndex(item => item.key === key) === -1) {\n      return key\n    }\n    appendIndexCount++\n  }\n  return `${parentKey}-error`\n}\n\n/**\n * Returns flat tree of TreeItem[] by received keys array\n * @param {TreeItem[]} items - source flat tree\n * @param {string[]} keys - list of items keys for return array of this items\n * @returns {TreeItem[]} - flat tree of items by received keys\n */\nexport const getFlatTreeItemsByKeys = (\n  items: TreeItem[],\n  keys: string[] = []\n): TreeItem[] => {\n  const resultItems = [] as TreeItem[]\n  for (let i = 0; i < keys.length; i++) {\n    const item = items.find(item => item.key === keys[i])\n    if (item) {\n      resultItems.push({ ...item })\n    }\n  }\n  return resultItems\n}\n\n/**\n * Apply changis from cache to source DB\n * @param {TreeItem[]} sourceItems - source tree\n * @param {TreeItem[]} cache - cache tree\n * @returns {[TreeItem[], TreeItem[]]} - ordered trees\n * with applyed changes as [sourceItems, cache]\n *\n */\nexport const applyCache = (\n  sourceItems: TreeItem[],\n  cache: TreeItem[]\n): [TreeItem[], TreeItem[]] => {\n  const resultSourceItems = getFlatTreeItemsArray(sourceItems)\n  const resultCache = getFlatTreeItemsArray(cache)\n\n  for (let i = 0; i < resultCache.length; i++) {\n    const currentItem = resultCache[i]\n    const posItem = resultSourceItems.findIndex(\n      item => item.key === currentItem.key\n    )\n    if (posItem !== -1) {\n      // if item exist then updating\n      resultSourceItems[posItem] = { ...currentItem }\n      if (resultSourceItems[i].deleted) {\n        markFlatTreeItemAsDeleted(resultSourceItems, currentItem)\n      }\n    } else {\n      // if new item\n      const uniqueKey = generateUniqueKey(resultSourceItems, currentItem.parent)\n      resultSourceItems.push({ ...currentItem, key: uniqueKey })\n      // replace old key by unique one\n      updateChildrenKeys(resultCache, currentItem.key, uniqueKey)\n      currentItem.key = uniqueKey\n      // resultCache[i].key = uniqueKey\n    }\n  }\n  for (let i = 0; i < resultSourceItems.length; i++) {\n    if (resultSourceItems[i].deleted) {\n      markFlatTreeItemAsDeleted(resultSourceItems, resultSourceItems[i])\n    }\n  }\n\n  const orderedResultSourceItems = reorderTree(resultSourceItems)\n  // get all keys to update cache. Some items may be deleted after apply\n  const keys = []\n  let orderedResultCache = [] as TreeItem[]\n  for (let i = 0; i < resultCache.length; i++) {\n    keys.push(resultCache[i].key)\n  }\n  orderedResultCache = reorderTree(\n    getFlatTreeItemsByKeys(resultSourceItems, keys)\n  )\n\n  return [orderedResultSourceItems, orderedResultCache]\n}\n\nconst updateChildrenKeys = (\n  cache: TreeItem[],\n  oldParentKey: string,\n  newParentKey: string\n) => {\n  for (let i = 0; i < cache.length; i++) {\n    if (cache[i].parent === oldParentKey) {\n      cache[i].parent = newParentKey\n    }\n  }\n}\n","import { createSlice, PayloadAction } from '@reduxjs/toolkit'\n\nimport { RootState, AppThunk } from '../../app/store'\nimport { defaultDBFlatTree } from './constants'\nimport { TreeItem } from './types'\nimport {\n  adoptDBItemsToTree,\n  getKeysFromFlatTree,\n  deleteItem,\n  alterItem,\n  addItemToTree,\n  applyCache\n} from './utils'\n\nexport interface TreeState {\n  items: TreeItem[]\n  cache: TreeItem[]\n  cacheExpandedKeys: string[]\n  itemsExpandedKeys: string[]\n}\n\nconst initialState: TreeState = {\n  items: adoptDBItemsToTree(defaultDBFlatTree),\n  cache: [] as TreeItem[],\n  cacheExpandedKeys: [] as string[],\n  itemsExpandedKeys: getKeysFromFlatTree(adoptDBItemsToTree(defaultDBFlatTree))\n}\n\ninterface ApplyAction {\n  dbItems: TreeItem[]\n  cache: TreeItem[]\n}\n\nconst treeSlice = createSlice({\n  name: 'public-repo-show/repos',\n  initialState,\n  reducers: {\n    add: (state, action: PayloadAction<TreeItem[]>) => {\n      state.cache = action.payload\n      state.cacheExpandedKeys = getKeysFromFlatTree(action.payload)\n    },\n    remove: (state, action: PayloadAction<TreeItem[]>) => {\n      state.cache = action.payload\n    },\n    alter: (state, action: PayloadAction<TreeItem[]>) => {\n      state.cache = action.payload\n    },\n    apply: (state, action: PayloadAction<ApplyAction>) => {\n      state.items = action.payload.dbItems\n      state.cache = action.payload.cache\n      state.cacheExpandedKeys = getKeysFromFlatTree(action.payload.cache)\n      state.itemsExpandedKeys = getKeysFromFlatTree(action.payload.dbItems)\n    },\n    reset: state => {\n      state.items = adoptDBItemsToTree(defaultDBFlatTree)\n      state.cache = [] as TreeItem[]\n      state.cacheExpandedKeys = [] as string[]\n      state.itemsExpandedKeys = getKeysFromFlatTree(\n        adoptDBItemsToTree(defaultDBFlatTree)\n      )\n    }\n  }\n})\n\nexport const { reset } = treeSlice.actions\n\nexport const selectCache = (state: RootState) => state.tree.cache\nexport const selectDB = (state: RootState) => state.tree.items\n\nexport const addItemAction =\n  (newItem: TreeItem): AppThunk =>\n  (dispatch, getState) => {\n    const cache = selectCache(getState())\n    const resultCache = addItemToTree(cache, newItem)\n    dispatch(treeSlice.actions.add(resultCache))\n  }\n\nexport const deleteItemAction =\n  (item: TreeItem): AppThunk =>\n  (dispatch, getState) => {\n    const cache = selectCache(getState())\n    const resultCache = deleteItem(cache, item)\n    dispatch(treeSlice.actions.remove(resultCache))\n  }\n\nexport const alterItemAction =\n  (item: TreeItem): AppThunk =>\n  (dispatch, getState) => {\n    const cache = selectCache(getState())\n    const resultCache = alterItem(cache, item)\n    dispatch(treeSlice.actions.alter(resultCache))\n  }\n\nexport const applyAction = (): AppThunk => (dispatch, getState) => {\n  const cache = selectCache(getState())\n  const dbItems = selectDB(getState())\n  const [resultDBItems, resultCache] = applyCache(dbItems, cache)\n  dispatch(\n    treeSlice.actions.apply({\n      dbItems: resultDBItems,\n      cache: resultCache\n    })\n  )\n}\n\nexport const tree = treeSlice.reducer\n","import React, { useState } from 'react'\nimport { Tree as AntTree, Row, Col, Button } from 'antd'\nimport { DeleteFilled } from '@ant-design/icons'\n\nimport { useAppSelector, useAppDispatch } from '../../utils/hooks'\nimport { addItemAction, TreeItem } from '../../store'\n\nexport const TreeDBContainer = () => {\n  const [selectedItem, setSelectedItem] = useState({} as TreeItem)\n  const items = useAppSelector(state => state.tree.items)\n  const expanded = useAppSelector(state => state.tree.itemsExpandedKeys)\n  const dispatch = useAppDispatch()\n\n  // store selected item for further editing or create new item\n  const onSelect = (selectedKeysValue: any, info: any) => {\n    if (info.selectedNodes.length) {\n      setSelectedItem({ ...info.selectedNodes[0], children: [] as TreeItem[] })\n    } else {\n      setSelectedItem({} as TreeItem)\n    }\n  }\n\n  const handleAdd = (): void => {\n    if (selectedItem.key) {\n      dispatch(addItemAction(selectedItem))\n    }\n  }\n\n  const getIcon = (props: any) => {\n    return props.data.deleted && <DeleteFilled style={{ color: 'red' }} />\n  }\n\n  return (\n    <div style={{ minWidth: '350px' }}>\n      <Row gutter={16} wrap={false} align='middle'>\n        <Col>\n          <Button onClick={handleAdd}>{'<<<'}</Button>\n        </Col>\n        <Col>\n          <AntTree\n            defaultExpandAll\n            checkStrictly\n            showIcon\n            icon={getIcon}\n            expandedKeys={expanded}\n            onSelect={onSelect}\n            selectedKeys={[selectedItem.key]}\n            treeData={items}\n          />\n        </Col>\n      </Row>\n    </div>\n  )\n}\n","import { useState } from 'react'\n\n/**\n * usePopupState hook\n */\nexport const usePopupState = ({ initialOpen = false } = {}): [\n  isOpen: boolean,\n  onToggle: () => void,\n  onOpen: () => void,\n  onClose: () => void\n] => {\n  const [isOpen, setIsOpen] = useState(initialOpen)\n\n  const onOpen = () => {\n    setIsOpen(true)\n  }\n\n  const onClose = () => {\n    setIsOpen(false)\n  }\n\n  const onToggle = () => {\n    setIsOpen(!isOpen)\n  }\n\n  return [isOpen, onToggle, onOpen, onClose]\n}\n","import React, { useState, useEffect } from 'react'\nimport { Modal, Input } from 'antd'\n\nimport { TreeItem } from '../../store'\n\ninterface ItemModalProps {\n  visible: boolean\n  title: string\n  item: TreeItem\n  onOk: (item: TreeItem) => void\n  onCancel: () => void\n}\n\nexport const ItemModal = ({\n  visible,\n  title,\n  item,\n  onOk,\n  onCancel\n}: ItemModalProps) => {\n  const [value, setValue] = useState(item.title)\n\n  // change title when changed parent item\n  useEffect(() => {\n    setValue(item.title)\n  }, [item])\n\n  const handleInput = (e: React.ChangeEvent<HTMLInputElement>) => {\n    setValue(e.target.value)\n  }\n\n  const handleOk = () => {\n    onOk({ ...item, title: value })\n    setValue('')\n  }\n\n  const handleCancel = () => {\n    // setValue('')\n    onCancel()\n  }\n\n  return (\n    <Modal\n      title={title}\n      destroyOnClose\n      visible={visible}\n      onOk={handleOk}\n      onCancel={handleCancel}\n      maskClosable={false}\n    >\n      <Input onChange={handleInput} value={value} />\n    </Modal>\n  )\n}\n","import React, { useState, useEffect } from 'react'\nimport { Tree as AntTree, Row, Col, Button } from 'antd'\nimport { DeleteFilled } from '@ant-design/icons'\n\nimport { TreeDBContainer } from './TreeDBContainer'\nimport {\n  reset,\n  deleteItemAction,\n  alterItemAction,\n  addItemAction,\n  applyAction,\n  TreeItem\n} from '../../store'\nimport { useAppSelector, useAppDispatch } from '../../utils/hooks'\nimport { usePopupState } from '../../utils/usePopupState'\nimport { getItemByKey } from '../../store/tree/utils'\nimport { ItemModal } from './ItemModal'\n\nexport const TreesContainer = (): JSX.Element => {\n  const items = useAppSelector(state => state.tree.cache || ([] as TreeItem[]))\n  const expanded = useAppSelector(state => state.tree.cacheExpandedKeys)\n  const [selectedItem, setSelectedItem] = useState({} as TreeItem)\n  const [newItem, setNewItem] = useState({} as TreeItem)\n  const [isOpenAddModal, onToggleAddModal] = usePopupState()\n  const [isOpenAlterModal, onToggleAlterModal] = usePopupState()\n\n  const dispatch = useAppDispatch()\n\n  // we need refresh actions accessible when make delete on item\n  useEffect(() => {\n    if (selectedItem.key) {\n      const freshItem = getItemByKey(items, selectedItem.key)\n      setSelectedItem({\n        ...(freshItem || ({} as TreeItem)),\n        children: [] as TreeItem[]\n      })\n      if (freshItem) {\n        // calculate temporary unique key for new item\n        const key = `${freshItem.key}-0-${\n          freshItem?.children ? freshItem?.children.length : 0\n        }`\n        const item = {\n          key,\n          title: key,\n          parent: freshItem.key,\n          deleted: false,\n          children: [] as TreeItem[]\n        } as TreeItem\n        setNewItem(item)\n      }\n    } else {\n      setNewItem({} as TreeItem)\n    }\n  }, [items, selectedItem.key])\n\n  // store selected item for further editing or create new item\n  const onSelect = (selectedKeysValue: any, info: any) => {\n    if (info.selectedNodes.length) {\n      setSelectedItem(info.selectedNodes[0])\n    } else {\n      setSelectedItem({} as TreeItem)\n    }\n  }\n\n  // reset to default state\n  const handleReset = () => {\n    dispatch(reset())\n  }\n\n  // display icon for deleted items\n  const getIcon = (props: any) => {\n    return props.data.deleted && <DeleteFilled style={{ color: 'red' }} />\n  }\n\n  // mark item as deleted\n  const handleDelete = () => {\n    if (selectedItem.key) {\n      dispatch(deleteItemAction(selectedItem))\n    }\n  }\n\n  // create new item for selected parent item stored in \"selectedItem\"\n  const handleNewItem = (item: TreeItem) => {\n    dispatch(addItemAction(item))\n    onToggleAddModal()\n  }\n\n  // create new item for selected parent item stored in \"selectedItem\"\n  const handleAlterItem = (item: TreeItem) => {\n    if (item.key) {\n      dispatch(alterItemAction(item))\n    }\n    onToggleAlterModal()\n  }\n\n  const handleApply = () => {\n    dispatch(applyAction())\n  }\n\n  return (\n    <div>\n      <Row gutter={16} wrap={false}>\n        <Col>\n          <div style={{ minWidth: '350px', minHeight: '400px' }}>\n            <AntTree\n              showIcon\n              icon={getIcon}\n              expandedKeys={expanded}\n              onSelect={onSelect}\n              selectedKeys={[selectedItem.key]}\n              treeData={items}\n            />\n          </div>\n        </Col>\n        <Col>\n          <TreeDBContainer />\n        </Col>\n      </Row>\n      <div style={{ marginTop: '20px' }}>\n        <Row gutter={8} wrap={false}>\n          <Col>\n            <ItemModal\n              visible={isOpenAddModal}\n              title={`Adding new item for parent: ${selectedItem.title}`}\n              item={newItem}\n              onOk={handleNewItem}\n              onCancel={onToggleAddModal}\n            />\n            <Button\n              disabled={!selectedItem.key || selectedItem.deleted}\n              onClick={onToggleAddModal}\n            >\n              +\n            </Button>\n          </Col>\n          <Col>\n            <Button disabled={!selectedItem.key} onClick={handleDelete}>\n              -\n            </Button>\n          </Col>\n          <Col>\n            <ItemModal\n              visible={isOpenAlterModal}\n              title={`Altering item: ${selectedItem.title}`}\n              item={selectedItem}\n              onOk={handleAlterItem}\n              onCancel={onToggleAlterModal}\n            />\n            <Button\n              disabled={!selectedItem.key || selectedItem.deleted}\n              onClick={onToggleAlterModal}\n            >\n              a\n            </Button>\n          </Col>\n          <Col span={2} />\n          <Col>\n            <Button onClick={handleApply}>Apply</Button>\n          </Col>\n          <Col>\n            <Button onClick={handleReset}>Reset</Button>\n          </Col>\n        </Row>\n      </div>\n    </div>\n  )\n}\n","import React from 'react'\nimport { TreesContainer } from '../components'\n\nexport const TreePage = () => {\n  return (\n    <div>\n      <TreesContainer />\n    </div>\n  )\n}\n","import React from 'react'\nimport './App.less'\nimport { Layout } from 'antd'\n\nimport { TreePage } from '../pages'\n\nexport function App() {\n  return (\n    <Layout style={{ minHeight: '100vh' }}>\n      <Layout.Header style={{ color: 'white', textAlign: 'center' }}>Tree editor</Layout.Header>\n      <Layout.Content style={{ padding: '20px 50px' }}>\n        <TreePage />\n        {/* <ApplicationRoutes routes={ROUTES} /> */}\n      </Layout.Content>\n      <Layout.Footer\n        style={{ textAlign: 'center', position: 'sticky', bottom: '0' }}\n      >\n        Manipulation tree elements\n      </Layout.Footer>\n    </Layout>\n  )\n}\n","import { configureStore, ThunkAction, Action } from '@reduxjs/toolkit'\nimport { tree } from '../store'\n\nexport const store = configureStore({\n  reducer: {\n    tree\n  }\n})\n\nexport type AppDispatch = typeof store.dispatch\nexport type RootState = ReturnType<typeof store.getState>\nexport type AppThunk<ReturnType = void> = ThunkAction<\n  ReturnType,\n  RootState,\n  unknown,\n  Action<string>\n>\n","import React from 'react'\nimport ReactDOM from 'react-dom'\nimport { Provider } from 'react-redux'\nimport { store } from './app'\n\nimport './index.css'\nimport { App } from './app'\n\nReactDOM.render(\n  <Provider store={store}>\n    <App />\n  </Provider>,\n  document.getElementById('root')\n)\n"],"sourceRoot":""}