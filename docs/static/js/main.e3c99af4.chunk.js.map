{"version":3,"sources":["utils/hooks.ts","store/tree/constants.ts","store/tree/utils.ts","store/tree/treeSlice.ts","components/Tree/TreeDBContainer.tsx","utils/usePopupState.ts","components/Tree/ItemModal.tsx","components/Tree/TreesContainer.tsx","pages/TreePage.tsx","app/App.tsx","app/store.ts","index.tsx"],"names":["useAppDispatch","useDispatch","useAppSelector","useSelector","defaultDBFlatTree","title","parent","deleted","key","getItemByKey","items","length","result","i","children","moveToParentByStep","findIndex","item","find","splice","push","reorderTree","tree","getFlatTreeItemsArray","limiter","movedChild","markItemAsDeleted","itemToDelete","startItem","markFlatTreeItemAsDeleted","pos","childrens","filter","dbItem","resultFlatTree","childs","getTreeFromFlatDB","nodes","childrenItems","adoptDBItemsToTree","treeItems","rootItem","getFlatTreeItemsByKeys","keys","resultItems","initialState","cache","cacheExpandedKeys","treeSlice","createSlice","name","reducers","add","state","action","payload","flatTree","getKeysFromFlatTree","remove","alter","apply","dbItems","reset","actions","selectCache","addItemAction","newItem","dispatch","getState","resultCache","addItemToTree","deleteItemAction","cacheTree","cloneDeep","deleteItem","alterItemAction","itemToAltered","alterItem","applyAction","sourceItems","resultSourceItems","currentItem","posItem","uniqueKey","parentKey","maxCount","appendIndexCount","generateUniqueKey","orderedResultSourceItems","orderedResultCache","applyCache","resultDBItems","reducer","TreeDBContainer","useState","selectedItem","setSelectedItem","style","minWidth","gutter","wrap","align","onClick","defaultExpandAll","checkStrictly","showIcon","icon","props","data","DeleteFilled","color","onSelect","selectedKeysValue","info","selectedNodes","selectedKeys","treeData","usePopupState","initialOpen","isOpen","setIsOpen","onOpen","onClose","onToggle","ItemModal","visible","onOk","onCancel","value","setValue","useEffect","destroyOnClose","maskClosable","onChange","e","target","TreesContainer","expanded","setNewItem","isOpenAddModal","onToggleAddModal","isOpenAlterModal","onToggleAlterModal","freshItem","minHeight","expandedKeys","marginTop","disabled","span","TreePage","App","Header","textAlign","Content","padding","Footer","position","bottom","store","configureStore","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.e3c99af4.chunk.js","sourcesContent":["import { TypedUseSelectorHook, useDispatch, useSelector } from 'react-redux'\nimport type { RootState, AppDispatch } from '../app/store'\n\n// Use throughout your app instead of plain `useDispatch` and `useSelector`\nexport const useAppDispatch = () => useDispatch<AppDispatch>()\nexport const useAppSelector: TypedUseSelectorHook<RootState> = useSelector\n","import { DBTreeItemList } from './types'\n\nexport const rootDBKey = '0'\n\nexport const maxIterationCount = 1000\n/**\n * Default DB. key of each element is unique value. It used as a\n * pointer to parent element.\n * Root element has parent === ''\n */\nexport const defaultDBFlatTree: DBTreeItemList = {\n  [rootDBKey]: {\n    title: 'root title',\n    parent: '',\n    deleted: false,\n    key: '0'\n  },\n  '0-0': {\n    title: 'child of root - 0',\n    parent: '0',\n    deleted: false,\n    key: '0-0'\n  },\n  '0-0-0': {\n    title: '0-0-0',\n    parent: '0-0',\n    deleted: false,\n    key: '0-0-0'\n  },\n  '0-0-1': {\n    title: '0-0-1',\n    parent: '0-0',\n    deleted: false,\n    key: '0-0-1'\n  },\n  '0-0-0-0': {\n    title: '0-0-0-0',\n    parent: '0-0-1',\n    deleted: false,\n    key: '0-0-0-0'\n  },\n  '0-0-0-1': {\n    title: '0-0-0-1',\n    parent: '0-0-1',\n    deleted: false,\n    key: '0-0-0-1'\n  },\n  '0-0-0-0-0': {\n    title: '0-0-0-0-0',\n    parent: '0-0-0-1',\n    deleted: false,\n    key: '0-0-0-0-0'\n  },\n  '0-0-0-2': {\n    title: '0-0-0-2',\n    parent: '0-0-1',\n    deleted: false,\n    key: '0-0-0-2'\n  },\n  '0-0-2': {\n    title: '0-0-2',\n    parent: '0-0',\n    deleted: false,\n    key: '0-0-2'\n  },\n  '0-1': {\n    title: 'child of root - 1',\n    parent: '0',\n    deleted: false,\n    key: '0-1'\n  },\n  '0-1-0': {\n    title: '0-1-0',\n    parent: '0-1',\n    deleted: false,\n    key: '0-1-0'\n  },\n  '0-1-1': {\n    title: '0-1-1',\n    parent: '0-1',\n    deleted: false,\n    key: '0-1-1'\n  },\n  '0-1-2': {\n    title: '0-1-2',\n    parent: '0-1',\n    deleted: false,\n    key: '0-1-2'\n  },\n  '0-2': {\n    title: 'child of root - 2',\n    parent: '0',\n    deleted: false,\n    key: '0-2'\n  }\n}\n","import { cloneDeep } from 'lodash'\nimport { TreeItem, DBTreeItemList } from './types'\nimport { rootDBKey, maxIterationCount } from './constants'\n\n/**\n * Find item in tree by key\n * @param {TreeItem[]} items - array of TreeItem to find with\n * @param {string} key - key of searched item\n * @returns {TreeItem | null} - link to item with received key\n */\nexport const getItemByKey = (\n  items: TreeItem[] = [],\n  key: string\n): TreeItem | null => {\n  if (items.length) {\n    let result = null\n    for (let i = 0; result == null && i < items.length; i++) {\n      if (items[i].key === key) {\n        return items[i]\n      }\n      result = getItemByKey(items[i].children, key)\n    }\n    return result\n  }\n  return null\n}\n\n/**\n * Check for each item for child existing. If child exists than go to next\n * loop. If there ar not child than finding parent. If parent found than we\n * extract current item from array and put to parent. If parent was not\n * finded too, than go to next loop.\n * If No child and no parent for each element mean that we have ordered tree\n * @param {TreeItem[]} items - array of TreeItem to move item to his parent\n * @returns {TreeItem | null} - item wich was moved to parent\n */\nexport const moveToParentByStep = (items: TreeItem[] = []): TreeItem | null => {\n  let result = null\n  if (items.length) {\n    for (let i = 0; result == null && i < items.length; i++) {\n      // check for existing children\n      if (items.findIndex(item => item.parent === items[i].key) === -1) {\n        // check for existing parent\n        const parent = items.find(item => item.key === items[i].parent)\n        if (parent) {\n          result = items[i]\n          items.splice(i, 1)\n          parent.children.push(result)\n          return result\n        }\n      }\n    }\n  }\n  return result\n}\n\n/**\n * Reorder tree. Takes tree and place childrens to its parents.\n * @param {TreeItem[]} tree - disordered or ordered tree. Tree will be\n * rebuild anyway\n * @returns {TreeItem[]} - ordered tree\n */\nexport const reorderTree = (tree: TreeItem[]): TreeItem[] => {\n  let result = getFlatTreeItemsArray(tree)\n  let limiter = 0\n  let movedChild = null\n  do {\n    movedChild = moveToParentByStep(result)\n    limiter++\n  } while (movedChild != null && limiter < maxIterationCount)\n  return result\n}\n\n/**\n * Mark item as \"deleted\". Preparing array for changing and call\n * recursive delete function on prepared array\n * @param {TreeItem[]} cache - current view tree\n * @param {TreeItem} item - item to be deleted\n *\n */\nexport const deleteItem = (\n  cache: TreeItem[] = [],\n  itemToDelete: TreeItem = {} as TreeItem\n) => {\n  const cacheTree = cloneDeep(cache)\n  itemToDelete.deleted = !itemToDelete.deleted\n  markItemAsDeleted(cacheTree, itemToDelete)\n  return cacheTree\n}\n\n/**\n * Mark item as \"deleted\" recursively from entire tree\n * @param {TreeItem[]} cache - current view tree\n * @param {TreeItem} item - item to be deleted\n *\n */\nexport const markItemAsDeleted = (\n  tree: TreeItem[],\n  itemToDelete: TreeItem = {} as TreeItem\n) => {\n  const startItem = getItemByKey(tree, itemToDelete.key)\n  if (startItem) {\n    // delete item and all his children\n    startItem.deleted = itemToDelete.deleted\n    for (let i = 0; i < startItem.children.length; i++) {\n      markItemAsDeleted(startItem.children, {\n        ...startItem.children[i],\n        deleted: itemToDelete.deleted\n      })\n    }\n  }\n}\n\n/**\n * mark item in flat array TreeItem[] as deleted\n * @param {TreeItem[]} items - items array where we should mark item deleted\n * @param {TreeItem} item - item to be deleted\n */\nexport const markFlatTreeItemAsDeleted = (\n  items: TreeItem[] = [],\n  itemToDelete: TreeItem = {} as TreeItem\n) => {\n  // first step delete item itself\n  const pos = items.findIndex(item => item.key === itemToDelete.key)\n  if (pos !== -1) {\n    items[pos].deleted = itemToDelete.deleted\n  }\n  // delete children\n  const childrens = items.filter(dbItem => dbItem.parent === itemToDelete.key)\n  for (let i = 0; i < childrens.length; i++) {\n    childrens[i].deleted = itemToDelete.deleted\n    markFlatTreeItemAsDeleted(items, childrens[i])\n  }\n}\n\n/**\n * Alter item's title.\n * @param {TreeItem[]} cache - current view tree\n * @param {TreeItem} item - item to be altered\n * @returns {TreeItem[]} - returns new cache with altered item title\n */\nexport const alterItem = (\n  cache: TreeItem[] = [],\n  itemToAltered: TreeItem = {} as TreeItem\n) => {\n  const resultCache = cloneDeep(cache)\n  const alterItem = getItemByKey(resultCache, itemToAltered.key)\n  if (alterItem) {\n    alterItem.title = itemToAltered.title\n  }\n  return resultCache\n}\n\n/**\n * Add item to tree\n * @param {TreeItem[]} cache - current view tree\n * @param {TreeItem} item - item to be added\n * @returns {TreeItem[]} - result tree with new item\n */\nexport const addItemToTree = (\n  tree: TreeItem[] = [] as TreeItem[],\n  newItem: TreeItem\n): TreeItem[] => {\n  const flatTree = getFlatTreeItemsArray(tree)\n  if (flatTree.findIndex(item => item.key === newItem.key) === -1) {\n    flatTree.push(newItem)\n  }\n  const orderedTree = reorderTree(flatTree)\n\n  return orderedTree\n}\n\n/**\n * returns flatten tree from tree\n * @param {TreeItem[]} tree - tree for flatting\n * @returns {DBTreeItem[]} - flat tree\n */\nexport const getFlatTreeItemsArray = (tree: TreeItem[]): TreeItem[] => {\n  const resultFlatTree = [] as TreeItem[]\n  for (const i in tree) {\n    const childs = getFlatTreeItemsArray(tree[i]?.children)\n    resultFlatTree.push({ ...tree[i], children: [] }, ...childs)\n  }\n  return resultFlatTree\n}\n\n/**\n * Returns tree for given root node key from flat source DB\n * @param {DBTreeItemList} nodes - original DB with root\n * @param {string} parent - root node key. It can be any node element. Tree\n * will be created from received key\n * @returns {TreeItem[]}  - result tree\n */\nexport const getTreeFromFlatDB = (\n  nodes: DBTreeItemList,\n  parent: string\n): TreeItem[] => {\n  const childrenItems = [] as TreeItem[]\n  for (const key in nodes) {\n    if (nodes[key].parent === parent) {\n      const children = getTreeFromFlatDB(nodes, key)\n      childrenItems.push({ ...nodes[key], ...{ children } })\n    }\n  }\n  return childrenItems\n}\n\n/**\n * Returns tree for given flat tree. Root will be finded throughout received\n * array with empty parent\n * @param {DBTreeItemList} nodes - flat tree. Only root has no parent\n * @returns {TreeItem[]}  - result tree\n */\nexport const adoptDBItemsToTree = (\n  items: DBTreeItemList = {} as DBTreeItemList\n): TreeItem[] => {\n  const treeItems = [] as TreeItem[]\n  const rootItem = { ...items[rootDBKey] }\n  // check for existing root item. If we have no root, than return empty array\n  if (rootItem.key) {\n    const children = getTreeFromFlatDB(items, rootItem.key)\n    treeItems.push({ ...rootItem, children })\n  }\n\n  return treeItems\n}\n\n/**\n * get all keys array from tree. For fetch updated items from\n * original DB to cache. Because delete operation may take effect\n * on missed cache items\n * @param {TreeItem[]} tree - flat tree of cache\n * @returns {string[]} - keys array\n */\nexport const getKeysFromFlatTree = (tree: TreeItem[]): string[] => {\n  const keys = [] as string[]\n  const flatTree = getFlatTreeItemsArray(tree)\n  for (const i in flatTree) {\n    keys.push(flatTree[i].key)\n  }\n  return keys\n}\n\n/**\n * Generate unuque key for new item. It based on real DB items keys.\n * @param {TreeItem[]} dbItems - source flat DB tree with original keys\n * @param {string} parentKey - key of parent wich will be base for build\n * unique key\n * @returns {string} - unique key\n */\nexport const generateUniqueKey = (\n  dbItems: TreeItem[] = [],\n  parentKey: string\n): string => {\n  // maxCount for prevent infinity loop\n  const maxCount = 1000\n  let appendIndexCount = 0\n  while (appendIndexCount < maxCount) {\n    const key = `${parentKey}-${appendIndexCount}`\n    if (dbItems.findIndex(item => item.key === key) === -1) {\n      return key\n    }\n    appendIndexCount++\n  }\n  return `${parentKey}-error`\n}\n\n/**\n * Returns flat tree of TreeItem[] by received keys array\n * @param {TreeItem[]} items - source flat tree\n * @param {string[]} keys - list of items keys for return array of this items\n * @returns {TreeItem[]} - flat tree of items by received keys\n */\nexport const getFlatTreeItemsByKeys = (\n  items: TreeItem[],\n  keys: string[] = []\n): TreeItem[] => {\n  const resultItems = [] as TreeItem[]\n  for (let i = 0; i < keys.length; i++) {\n    const item = items.find(item => item.key === keys[i])\n    if (item) {\n      resultItems.push({ ...item })\n    }\n  }\n  return resultItems\n}\n\n/**\n * Apply changis from cache to source DB\n * @param {TreeItem[]} sourceItems - source tree\n * @param {TreeItem[]} cache - cache tree\n * @returns {[TreeItem[], TreeItem[]]} - ordered trees\n * with applyed changes as [sourceItems, cache]\n *\n */\nexport const applyCache = (\n  sourceItems: TreeItem[],\n  cache: TreeItem[]\n): [TreeItem[], TreeItem[]] => {\n  const resultSourceItems = getFlatTreeItemsArray(sourceItems)\n  const resultCache = getFlatTreeItemsArray(cache)\n\n  for (let i = 0; i < resultCache.length; i++) {\n    const currentItem = resultCache[i]\n    const posItem = resultSourceItems.findIndex(\n      item => item.key === currentItem.key\n    )\n    if (posItem !== -1) {\n      // if item exist then updating\n      resultSourceItems[posItem] = { ...currentItem }\n      markFlatTreeItemAsDeleted(resultSourceItems, currentItem)\n    } else {\n      // if new item\n      const uniqueKey = generateUniqueKey(resultSourceItems, currentItem.parent)\n      resultSourceItems.push({ ...currentItem, key: uniqueKey })\n      // replace old key by unique one\n      resultCache[i].key = uniqueKey\n    }\n  }\n  const orderedResultSourceItems = reorderTree(resultSourceItems)\n  // get all keys to update cache. Some items may be deleted after apply\n  const keys = []\n  let orderedResultCache = [] as TreeItem[]\n  for (let i = 0; i < resultCache.length; i++) {\n    keys.push(resultCache[i].key)\n    orderedResultCache = reorderTree(\n      getFlatTreeItemsByKeys(resultSourceItems, keys)\n    )\n  }\n\n  return [orderedResultSourceItems, orderedResultCache]\n}\n","import { createSlice, PayloadAction } from '@reduxjs/toolkit'\n\nimport { RootState, AppThunk } from '../../app/store'\nimport { defaultDBFlatTree } from './constants'\nimport { TreeItem } from './types'\nimport {\n  adoptDBItemsToTree,\n  getKeysFromFlatTree,\n  deleteItem,\n  alterItem,\n  addItemToTree,\n  applyCache\n} from './utils'\n\nexport interface TreeState {\n  items: TreeItem[]\n  cache: TreeItem[]\n  cacheExpandedKeys: string[]\n}\n\nconst initialState: TreeState = {\n  items: adoptDBItemsToTree(defaultDBFlatTree),\n  cache: [] as TreeItem[],\n  cacheExpandedKeys: [] as string[]\n}\n\ninterface ApplyAction {\n  dbItems: TreeItem[]\n  cache: TreeItem[]\n}\n\nconst treeSlice = createSlice({\n  name: 'public-repo-show/repos',\n  initialState,\n  reducers: {\n    add: (state, action: PayloadAction<TreeItem[]>) => {\n      state.cache = action.payload\n      state.cacheExpandedKeys = getKeysFromFlatTree(action.payload)\n    },\n    remove: (state, action: PayloadAction<TreeItem[]>) => {\n      state.cache = action.payload\n    },\n    alter: (state, action: PayloadAction<TreeItem[]>) => {\n      state.cache = action.payload\n    },\n    apply: (state, action: PayloadAction<ApplyAction>) => {\n      state.items = action.payload.dbItems\n      state.cache = action.payload.cache\n    },\n    reset: state => {\n      state.items = adoptDBItemsToTree(defaultDBFlatTree)\n      state.cache = [] as TreeItem[]\n      state.cacheExpandedKeys = [] as string[]\n    }\n  }\n})\n\nexport const { reset } = treeSlice.actions\n\nexport const selectCache = (state: RootState) => state.tree.cache\nexport const selectDB = (state: RootState) => state.tree.items\n\nexport const addItemAction =\n  (newItem: TreeItem): AppThunk =>\n  (dispatch, getState) => {\n    const cache = selectCache(getState())\n    const resultCache = addItemToTree(cache, newItem)\n    dispatch(treeSlice.actions.add(resultCache))\n  }\n\nexport const deleteItemAction =\n  (item: TreeItem): AppThunk =>\n  (dispatch, getState) => {\n    const cache = selectCache(getState())\n    const resultCache = deleteItem(cache, item)\n    dispatch(treeSlice.actions.remove(resultCache))\n  }\n\nexport const alterItemAction =\n  (item: TreeItem): AppThunk =>\n  (dispatch, getState) => {\n    const cache = selectCache(getState())\n    const resultCache = alterItem(cache, item)\n    dispatch(treeSlice.actions.alter(resultCache))\n  }\n\nexport const applyAction = (): AppThunk => (dispatch, getState) => {\n  const cache = selectCache(getState())\n  const dbItems = selectDB(getState())\n  const [resultDBItems, resultCache] = applyCache(dbItems, cache)\n  dispatch(\n    treeSlice.actions.apply({\n      dbItems: resultDBItems,\n      cache: resultCache\n    })\n  )\n}\n\nexport const tree = treeSlice.reducer\n","import React, { useState } from 'react'\nimport { Tree as AntTree, Row, Col, Button } from 'antd'\nimport { DeleteFilled } from '@ant-design/icons'\n\nimport { useAppSelector, useAppDispatch } from '../../utils/hooks'\nimport { addItemAction, TreeItem } from '../../store'\n\nexport const TreeDBContainer = () => {\n  const [selectedItem, setSelectedItem] = useState({} as TreeItem)\n  const items = useAppSelector(state => state.tree.items)\n  const dispatch = useAppDispatch()\n\n  // store selected item for further editing or create new item\n  const onSelect = (selectedKeysValue: any, info: any) => {\n    if (info.selectedNodes.length) {\n      setSelectedItem({ ...info.selectedNodes[0], children: [] as TreeItem[] })\n    } else {\n      setSelectedItem({} as TreeItem)\n    }\n  }\n\n  const handleAdd = (): void => {\n    if (selectedItem.key) {\n      dispatch(addItemAction(selectedItem))\n    }\n  }\n\n  const getIcon = (props: any) => {\n    return props.data.deleted && <DeleteFilled style={{ color: 'red' }} />\n  }\n\n  return (\n    <div style={{ minWidth: '350px' }}>\n      <Row gutter={16} wrap={false} align='middle'>\n        <Col>\n          <Button onClick={handleAdd}>{'<<<'}</Button>\n        </Col>\n        <Col>\n          <AntTree\n            defaultExpandAll\n            checkStrictly\n            showIcon\n            icon={getIcon}\n            onSelect={onSelect}\n            selectedKeys={[selectedItem.key]}\n            treeData={items}\n          />\n        </Col>\n      </Row>\n    </div>\n  )\n}\n","import { useState } from 'react'\n\n/**\n * usePopupState hook\n */\nexport const usePopupState = ({ initialOpen = false } = {}): [\n  isOpen: boolean,\n  onToggle: () => void,\n  onOpen: () => void,\n  onClose: () => void\n] => {\n  const [isOpen, setIsOpen] = useState(initialOpen)\n\n  const onOpen = () => {\n    setIsOpen(true)\n  }\n\n  const onClose = () => {\n    setIsOpen(false)\n  }\n\n  const onToggle = () => {\n    setIsOpen(!isOpen)\n  }\n\n  return [isOpen, onToggle, onOpen, onClose]\n}\n","import React, { useState, useEffect } from 'react'\nimport { Modal, Input } from 'antd'\n\nimport { TreeItem } from '../../store'\n\ninterface ItemModalProps {\n  visible: boolean\n  title: string\n  item: TreeItem\n  onOk: (item: TreeItem) => void\n  onCancel: () => void\n}\n\nexport const ItemModal = ({\n  visible,\n  title,\n  item,\n  onOk,\n  onCancel\n}: ItemModalProps) => {\n  const [value, setValue] = useState(item.title)\n\n  // change title when changed parent item\n  useEffect(() => {\n    setValue(item.title)\n  }, [item])\n\n  const handleInput = (e: React.ChangeEvent<HTMLInputElement>) => {\n    setValue(e.target.value)\n  }\n\n  const handleOk = () => {\n    onOk({ ...item, title: value })\n    setValue('')\n  }\n\n  const handleCancel = () => {\n    // setValue('')\n    onCancel()\n  }\n\n  return (\n    <Modal\n      title={title}\n      destroyOnClose\n      visible={visible}\n      onOk={handleOk}\n      onCancel={handleCancel}\n      maskClosable={false}\n    >\n      <Input onChange={handleInput} value={value} />\n    </Modal>\n  )\n}\n","import React, { useState, useEffect } from 'react'\nimport { Tree as AntTree, Row, Col, Button } from 'antd'\nimport { DeleteFilled } from '@ant-design/icons'\n\nimport { TreeDBContainer } from './TreeDBContainer'\nimport {\n  reset,\n  deleteItemAction,\n  alterItemAction,\n  addItemAction,\n  applyAction,\n  TreeItem\n} from '../../store'\nimport { useAppSelector, useAppDispatch } from '../../utils/hooks'\nimport { usePopupState } from '../../utils/usePopupState'\nimport { getItemByKey } from '../../store/tree/utils'\nimport { ItemModal } from './ItemModal'\n\nexport const TreesContainer = (): JSX.Element => {\n  const items = useAppSelector(state => state.tree.cache || ([] as TreeItem[]))\n  const expanded = useAppSelector(state => state.tree.cacheExpandedKeys)\n  const [selectedItem, setSelectedItem] = useState({} as TreeItem)\n  const [newItem, setNewItem] = useState({} as TreeItem)\n  const [isOpenAddModal, onToggleAddModal] = usePopupState()\n  const [isOpenAlterModal, onToggleAlterModal] = usePopupState()\n\n  const dispatch = useAppDispatch()\n\n  // we need refresh actions accessible when make delete on item\n  useEffect(() => {\n    if (selectedItem.key) {\n      const freshItem = getItemByKey(items, selectedItem.key)\n      setSelectedItem({\n        ...(freshItem || ({} as TreeItem)),\n        children: [] as TreeItem[]\n      })\n      if (freshItem) {\n        // calculate temporary unique key for new item\n        const key = `${freshItem.key}-0-${\n          freshItem?.children ? freshItem?.children.length : 0\n        }`\n        const item = {\n          key,\n          title: key,\n          parent: freshItem.key,\n          deleted: false,\n          children: [] as TreeItem[]\n        } as TreeItem\n        setNewItem(item)\n      }\n    } else {\n      setNewItem({} as TreeItem)\n    }\n  }, [items, selectedItem.key])\n\n  // store selected item for further editing or create new item\n  const onSelect = (selectedKeysValue: any, info: any) => {\n    if (info.selectedNodes.length) {\n      setSelectedItem(info.selectedNodes[0])\n    } else {\n      setSelectedItem({} as TreeItem)\n    }\n  }\n\n  // reset to default state\n  const handleReset = () => {\n    dispatch(reset())\n  }\n\n  // display icon for deleted items\n  const getIcon = (props: any) => {\n    return props.data.deleted && <DeleteFilled style={{ color: 'red' }} />\n  }\n\n  // mark item as deleted\n  const handleDelete = () => {\n    if (selectedItem.key) {\n      dispatch(deleteItemAction(selectedItem))\n    }\n  }\n\n  // create new item for selected parent item stored in \"selectedItem\"\n  const handleNewItem = (item: TreeItem) => {\n    dispatch(addItemAction(item))\n    onToggleAddModal()\n  }\n\n  // create new item for selected parent item stored in \"selectedItem\"\n  const handleAlterItem = (item: TreeItem) => {\n    if (item.key) {\n      dispatch(alterItemAction(item))\n    }\n    onToggleAlterModal()\n  }\n\n  const handleApply = () => {\n    dispatch(applyAction())\n  }\n\n  return (\n    <div>\n      <Row gutter={16} wrap={false}>\n        <Col>\n          <div style={{ minWidth: '350px', minHeight: '400px' }}>\n            <AntTree\n              showIcon\n              icon={getIcon}\n              expandedKeys={expanded}\n              onSelect={onSelect}\n              selectedKeys={[selectedItem.key]}\n              treeData={items}\n            />\n          </div>\n        </Col>\n        <Col>\n          <TreeDBContainer />\n        </Col>\n      </Row>\n      <div style={{ marginTop: '20px' }}>\n        <Row gutter={8} wrap={false}>\n          <Col>\n            <ItemModal\n              visible={isOpenAddModal}\n              title={`Adding new item for parent: ${selectedItem.title}`}\n              item={newItem}\n              onOk={handleNewItem}\n              onCancel={onToggleAddModal}\n            />\n            <Button\n              disabled={!selectedItem.key || selectedItem.deleted}\n              onClick={onToggleAddModal}\n            >\n              +\n            </Button>\n          </Col>\n          <Col>\n            <Button disabled={!selectedItem.key} onClick={handleDelete}>\n              -\n            </Button>\n          </Col>\n          <Col>\n            <ItemModal\n              visible={isOpenAlterModal}\n              title={`Altering item: ${selectedItem.title}`}\n              item={selectedItem}\n              onOk={handleAlterItem}\n              onCancel={onToggleAlterModal}\n            />\n            <Button\n              disabled={!selectedItem.key || selectedItem.deleted}\n              onClick={onToggleAlterModal}\n            >\n              a\n            </Button>\n          </Col>\n          <Col span={2} />\n          <Col>\n            <Button onClick={handleApply}>Apply</Button>\n          </Col>\n          <Col>\n            <Button onClick={handleReset}>Reset</Button>\n          </Col>\n        </Row>\n      </div>\n    </div>\n  )\n}\n","import React from 'react'\nimport { TreesContainer } from '../components'\n\nexport const TreePage = () => {\n  return (\n    <div>\n      <TreesContainer />\n    </div>\n  )\n}\n","import React from 'react'\nimport './App.less'\nimport { Layout } from 'antd'\n\nimport { TreePage } from '../pages'\n\nexport function App() {\n  return (\n    <Layout style={{ minHeight: '100vh' }}>\n      <Layout.Header style={{ color: 'white', textAlign: 'center' }}>Tree editor</Layout.Header>\n      <Layout.Content style={{ padding: '20px 50px' }}>\n        <TreePage />\n        {/* <ApplicationRoutes routes={ROUTES} /> */}\n      </Layout.Content>\n      <Layout.Footer\n        style={{ textAlign: 'center', position: 'sticky', bottom: '0' }}\n      >\n        Manipulation tree elements\n      </Layout.Footer>\n    </Layout>\n  )\n}\n","import { configureStore, ThunkAction, Action } from '@reduxjs/toolkit'\nimport { tree } from '../store'\n\nexport const store = configureStore({\n  reducer: {\n    tree\n  }\n})\n\nexport type AppDispatch = typeof store.dispatch\nexport type RootState = ReturnType<typeof store.getState>\nexport type AppThunk<ReturnType = void> = ThunkAction<\n  ReturnType,\n  RootState,\n  unknown,\n  Action<string>\n>\n","import React from 'react'\nimport ReactDOM from 'react-dom'\nimport { Provider } from 'react-redux'\nimport { store } from './app'\n\nimport './index.css'\nimport { App } from './app'\n\nReactDOM.render(\n  <Provider store={store}>\n    <App />\n  </Provider>,\n  document.getElementById('root')\n)\n"],"sourceRoot":""}